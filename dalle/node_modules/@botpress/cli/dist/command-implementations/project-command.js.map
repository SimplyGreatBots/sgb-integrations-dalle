{
  "version": 3,
  "sources": ["../../src/command-implementations/project-command.ts"],
  "sourcesContent": ["import type * as bpclient from '@botpress/client'\nimport type * as bpsdk from '@botpress/sdk'\nimport type { YargsConfig } from '@bpinternal/yargs-extra'\nimport bluebird from 'bluebird'\nimport chalk from 'chalk'\nimport fs from 'fs'\nimport _ from 'lodash'\nimport pathlib from 'path'\nimport semver from 'semver'\nimport { ApiClient } from '../api/client'\nimport * as codegen from '../code-generation'\nimport type * as config from '../config'\nimport * as consts from '../consts'\nimport * as errors from '../errors'\nimport { formatIntegrationRef, IntegrationRef } from '../integration-ref'\nimport type { CommandArgv, CommandDefinition } from '../typings'\nimport * as utils from '../utils'\nimport { GlobalCommand } from './global-command'\n\nexport type ProjectCommandDefinition = CommandDefinition<typeof config.schemas.project>\nexport type ProjectCache = { botId: string; devId: string }\n\ntype ConfigurableProjectPaths = { entryPoint: string; outDir: string; workDir: string }\ntype ConstantProjectPaths = typeof consts.fromOutDir & typeof consts.fromWorkDir\ntype AllProjectPaths = ConfigurableProjectPaths & ConstantProjectPaths\n\ntype ApiIntegrationInstance = utils.types.Merge<bpsdk.IntegrationInstance<string>, { id: string }>\ntype LocalIntegrationInstance = utils.types.Merge<bpsdk.IntegrationInstance<string>, { id: null }>\n\nclass ProjectPaths extends utils.path.PathStore<keyof AllProjectPaths> {\n  public constructor(argv: CommandArgv<ProjectCommandDefinition>) {\n    const absWorkDir = utils.path.absoluteFrom(utils.path.cwd(), argv.workDir)\n    const absEntrypoint = utils.path.absoluteFrom(absWorkDir, argv.entryPoint)\n    const absOutDir = utils.path.absoluteFrom(absWorkDir, argv.outDir)\n    super({\n      workDir: absWorkDir,\n      entryPoint: absEntrypoint,\n      outDir: absOutDir,\n      ..._.mapValues(consts.fromOutDir, (p) => utils.path.absoluteFrom(absOutDir, p)),\n      ..._.mapValues(consts.fromWorkDir, (p) => utils.path.absoluteFrom(absWorkDir, p)),\n    })\n  }\n}\n\ntype PromptSecretsOptions = {\n  knownSecrets: string[]\n  formatEnv: boolean\n}\nconst PROMPT_SECRET_DEFAULTS = { knownSecrets: [], formatEnv: false } satisfies PromptSecretsOptions\n\nexport abstract class ProjectCommand<C extends ProjectCommandDefinition> extends GlobalCommand<C> {\n  protected override async bootstrap() {\n    await super.bootstrap()\n    await this._notifyUpdateSdk()\n  }\n\n  protected get projectPaths() {\n    return new ProjectPaths(this.argv)\n  }\n\n  protected get projectCache() {\n    return new utils.cache.FSKeyValueCache<ProjectCache>(this.projectPaths.abs.projectCacheFile)\n  }\n\n  protected async prepareBotIntegrationInstances(bot: bpsdk.Bot, api: ApiClient) {\n    const integrationList = _(bot.props.integrations).values().filter(utils.guards.is.defined).value()\n\n    const { apiInstances, localInstances } = this._splitApiAndLocalIntegrationInstances(integrationList)\n\n    const fetchedInstances: ApiIntegrationInstance[] = await bluebird.map(localInstances, async (instance) => {\n      const ref: IntegrationRef = { type: 'name', name: instance.name, version: instance.version }\n      const integration = await api.findIntegration(ref)\n      if (!integration) {\n        const formattedRef = formatIntegrationRef(ref)\n        throw new errors.BotpressCLIError(`Integration \"${formattedRef}\" not found`)\n      }\n      return { ...instance, id: integration.id }\n    })\n\n    return {\n      integrations: _([...fetchedInstances, ...apiInstances])\n        .keyBy((i) => i.id)\n        .mapValues(({ enabled, configuration }) => ({ enabled, configuration }))\n        .value(),\n    }\n  }\n\n  private _splitApiAndLocalIntegrationInstances(instances: bpsdk.IntegrationInstance<string>[]): {\n    apiInstances: ApiIntegrationInstance[]\n    localInstances: LocalIntegrationInstance[]\n  } {\n    const apiInstances: ApiIntegrationInstance[] = []\n    const localInstances: LocalIntegrationInstance[] = []\n    for (const { id, ...instance } of instances) {\n      if (id) {\n        apiInstances.push({ ...instance, id })\n      } else {\n        localInstances.push({ ...instance, id: null })\n      }\n    }\n\n    return { apiInstances, localInstances }\n  }\n\n  protected prepareBot(bot: bpsdk.Bot) {\n    return {\n      ...bot.props,\n      configuration: bot.props.configuration\n        ? {\n            ...bot.props.configuration,\n            schema: utils.schema.mapZodToJsonSchema(bot.props.configuration),\n          }\n        : undefined,\n      events: bot.props.events\n        ? _.mapValues(bot.props.events, (event) => ({\n            ...event,\n            schema: utils.schema.mapZodToJsonSchema(event),\n          }))\n        : undefined,\n      states: bot.props.states\n        ? _.mapValues(bot.props.states, (state) => ({\n            ...state,\n            schema: utils.schema.mapZodToJsonSchema(state),\n          }))\n        : undefined,\n    }\n  }\n\n  protected prepareIntegrationDefinition(integration: bpsdk.IntegrationDefinition) {\n    return {\n      ...integration,\n      secrets: undefined,\n      configuration: integration.configuration\n        ? {\n            ...integration.configuration,\n            schema: utils.schema.mapZodToJsonSchema(integration.configuration),\n          }\n        : undefined,\n      events: integration.events\n        ? _.mapValues(integration.events, (event) => ({\n            ...event,\n            schema: utils.schema.mapZodToJsonSchema(event),\n          }))\n        : undefined,\n      actions: integration.actions\n        ? _.mapValues(integration.actions, (action) => ({\n            ...action,\n            input: {\n              ...action.input,\n              schema: utils.schema.mapZodToJsonSchema(action.input),\n            },\n            output: {\n              ...action.output,\n              schema: utils.schema.mapZodToJsonSchema(action.output),\n            },\n          }))\n        : undefined,\n      channels: integration.channels\n        ? _.mapValues(integration.channels, (channel) => ({\n            ...channel,\n            messages: _.mapValues(channel.messages, (message) => ({\n              ...message,\n              schema: utils.schema.mapZodToJsonSchema(message),\n            })),\n          }))\n        : undefined,\n      states: integration.states\n        ? _.mapValues(integration.states, (state) => ({\n            ...state,\n            schema: utils.schema.mapZodToJsonSchema(state),\n          }))\n        : undefined,\n    }\n  }\n\n  protected async readIntegrationDefinitionFromFS(\n    projectPaths: utils.path.PathStore<'workDir' | 'definition'> = this.projectPaths\n  ): Promise<bpsdk.IntegrationDefinition | undefined> {\n    const abs = projectPaths.abs\n    const rel = projectPaths.rel('workDir')\n\n    if (!fs.existsSync(abs.definition)) {\n      this.logger.debug(`Integration definition not found at ${rel.definition}`)\n      return\n    }\n\n    const { outputFiles } = await utils.esbuild.buildEntrypoint({\n      cwd: abs.workDir,\n      outfile: '',\n      entrypoint: rel.definition,\n      write: false,\n    })\n\n    const artifact = outputFiles[0]\n    if (!artifact) {\n      throw new errors.BotpressCLIError('Could not read integration definition')\n    }\n\n    const { default: definition } = utils.require.requireJsCode<{ default: bpsdk.IntegrationDefinition }>(artifact.text)\n    return definition\n  }\n\n  protected async writeGeneratedFilesToOutFolder(files: codegen.File[]) {\n    for (const file of files) {\n      const filePath = utils.path.absoluteFrom(this.projectPaths.abs.outDir, file.path)\n      const dirPath = pathlib.dirname(filePath)\n      await fs.promises.mkdir(dirPath, { recursive: true })\n      await fs.promises.writeFile(filePath, file.content)\n    }\n  }\n\n  protected displayWebhookUrls(bot: bpclient.Bot) {\n    if (!_.keys(bot.integrations).length) {\n      this.logger.debug('No integrations in bot')\n      return\n    }\n\n    this.logger.log('Integrations:')\n    for (const integration of Object.values(bot.integrations).filter(utils.guards.is.defined)) {\n      if (!integration.enabled) {\n        this.logger.log(`${chalk.grey(integration.name)} ${chalk.italic('(disabled)')}: ${integration.webhookUrl}`, {\n          prefix: { symbol: '\u25CB', indent: 2 },\n        })\n      } else {\n        this.logger.log(`${chalk.bold(integration.name)} : ${integration.webhookUrl}`, {\n          prefix: { symbol: '\u25CF', indent: 2 },\n        })\n      }\n    }\n  }\n\n  protected async promptSecrets(\n    integrationDef: bpsdk.IntegrationDefinition,\n    argv: YargsConfig<typeof config.schemas.secrets>,\n    opts: Partial<PromptSecretsOptions> = {}\n  ): Promise<Record<string, string>> {\n    const options = { ...PROMPT_SECRET_DEFAULTS, ...opts }\n\n    const { secrets: secretDefinitions } = integrationDef\n    if (!secretDefinitions) {\n      return {}\n    }\n\n    const secretArgv = this._parseArgvSecrets(argv.secrets)\n    const invalidSecret = Object.keys(secretArgv).find((s) => !secretDefinitions[s])\n    if (invalidSecret) {\n      throw new errors.BotpressCLIError(`Secret ${invalidSecret} is not defined in integration definition`)\n    }\n\n    const values: Record<string, string> = {}\n    for (const [secretName, { optional }] of Object.entries(secretDefinitions)) {\n      const argvSecret = secretArgv[secretName]\n      if (argvSecret) {\n        this.logger.debug(`Using secret \"${secretName}\" from argv`)\n        values[secretName] = argvSecret\n        continue\n      }\n\n      const alreadyKnown = options.knownSecrets.includes(secretName)\n      let mode: string\n      if (alreadyKnown) {\n        mode = 'already set'\n      } else if (optional) {\n        mode = 'optional'\n      } else {\n        mode = 'required'\n      }\n\n      const prompted = await this.prompt.text(`Enter value for secret \"${secretName}\" (${mode})`)\n      if (prompted) {\n        values[secretName] = prompted\n        continue\n      }\n\n      if (alreadyKnown) {\n        this.logger.log(`Secret \"${secretName}\" is unchanged`)\n      } else if (optional) {\n        this.logger.warn(`Secret \"${secretName}\" is unassigned`)\n      } else {\n        throw new errors.BotpressCLIError(`Secret \"${secretName}\" is required`)\n      }\n    }\n\n    if (!options.formatEnv) {\n      return values\n    }\n\n    const envVariables = _.mapKeys(values, (_v, k) => codegen.secretEnvVariableName(k))\n    return envVariables\n  }\n\n  private _parseArgvSecrets(argvSecrets: string[]): Record<string, string> {\n    const parsed: Record<string, string> = {}\n    for (const secret of argvSecrets) {\n      const [key, value] = this._splitOnce(secret, '=')\n      if (!value) {\n        throw new errors.BotpressCLIError(\n          `Secret \"${key}\" is missing a value. Expected format: \"SECRET_NAME=secretValue\"`\n        )\n      }\n      parsed[key!] = value\n    }\n\n    return parsed\n  }\n\n  private _splitOnce = (text: string, separator: string): [string, string | undefined] => {\n    const index = text.indexOf(separator)\n    if (index === -1) {\n      return [text, undefined]\n    }\n    return [text.slice(0, index), text.slice(index + 1)]\n  }\n\n  private _notifyUpdateSdk = async (): Promise<void> => {\n    try {\n      this.logger.debug('Checking if sdk is up to date')\n\n      const { workDir } = this.projectPaths.abs\n      const projectPkgJson = await utils.pkgJson.readPackageJson(workDir)\n      if (!projectPkgJson) {\n        this.logger.debug(`Could not find package.json at \"${workDir}\"`)\n        return\n      }\n\n      const sdkPackageName = '@botpress/sdk'\n      const actualSdkVersion = utils.pkgJson.findDependency(projectPkgJson, sdkPackageName)\n      if (!actualSdkVersion) {\n        this.logger.debug(`Could not find dependency \"${sdkPackageName}\" in project package.json`)\n        return\n      }\n\n      const actualCleanedSdkVersion = semver.valid(semver.coerce(actualSdkVersion))\n      if (!actualCleanedSdkVersion) {\n        this.logger.debug(`Invalid sdk version \"${actualSdkVersion}\" in project package.json`)\n        return\n      }\n\n      const cliPkgJson = await this.readPkgJson()\n      const expectedSdkVersion = utils.pkgJson.findDependency(cliPkgJson, sdkPackageName)\n      if (!expectedSdkVersion) {\n        this.logger.debug(`Could not find dependency \"${sdkPackageName}\" in cli package.json`)\n        return\n      }\n\n      const expectedCleanedSdkVersion = semver.valid(semver.coerce(expectedSdkVersion))\n      if (!expectedCleanedSdkVersion) {\n        this.logger.debug(`Invalid sdk version \"${expectedSdkVersion}\" in cli package.json`)\n        return\n      }\n\n      if (semver.eq(actualCleanedSdkVersion, expectedCleanedSdkVersion)) {\n        return\n      }\n\n      const diff = semver.diff(actualCleanedSdkVersion, expectedCleanedSdkVersion)\n      if (!diff) {\n        this.logger.debug(`Could not compare versions \"${actualCleanedSdkVersion}\" and \"${expectedCleanedSdkVersion}\"`)\n        return\n      }\n\n      const errorMsg = `Project SDK version is \"${actualCleanedSdkVersion}\", but expected \"${expectedCleanedSdkVersion}\"`\n      if (utils.semver.releases.lt(diff, 'minor')) {\n        this.logger.debug(`${errorMsg}. This may cause compatibility issues.`)\n        return\n      }\n\n      this.logger.warn(chalk.bold(`${errorMsg}. This will cause compatibility issues.`))\n    } catch (thrown) {\n      const err = errors.BotpressCLIError.map(thrown)\n      this.logger.debug(`Failed to check if sdk is up to date: ${err.message}`)\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["_", "bluebird", "fs", "pathlib", "chalk", "semver"]
}
